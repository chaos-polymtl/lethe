# SPDX-FileCopyrightText: Copyright (c) 2025 The Lethe Authors
# SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception OR LGPL-2.1-or-later

"""
This code rearranges the output of the simplex mesh simulations to match the hierarchy and formatting of that obtained for the quad mesh. The simulations generate 
initially a separate folder and output file for each mesh resolution and each pair of velocity and pressure shape functions. This code reorganizes all of the folders 
into a new folder structure where each folder corresponds to a pair of velocity and pressure shape functions and contains a L2Error.dat file that contains the error
for the different mesh resolutions, similar to the one obtained when using mesh adaptation with the quadrilateral mesh.
"""
# %%
import ipdb
import os
import numpy as np
from pathlib import Path
import re
import shutil

# Define the repository
base_dir = os.getcwd()
# Define the base filename and possible suffixes
path=Path(base_dir)

poly_deg_min=1
poly_deg_max=2
n_poly_deg = 2

poly_deg = (np.linspace(poly_deg_min, poly_deg_max, n_poly_deg)).astype(int)

col_widths = [6, 12, 5, 11, 5, 8, 7]  # Adjust output files structure

for poly_deg_u in poly_deg:
    for poly_deg_p in  range(1, poly_deg_u+1):
        mat=[]
        folder_name = f"mms_2d_steady_degu_{poly_deg_u}_degp_{poly_deg_p}"
        folder_path = os.path.join(base_dir, folder_name)

        # Create the folder if it doesn't exist
        os.makedirs(folder_path, exist_ok=True)
        print(f"Created: {folder_path}")

        for folders_MMS in path.glob("mms*"):
          
          if folders_MMS.is_dir():
            # Pattern of folders to open where each folder is in the form MMS_2D_steady_mesh_ref_x_degu_y_degp_z for when y and z are fixed
            pattern_1 = rf"mesh_ref_(\d+)_degu_{poly_deg_u}_degp_{poly_deg_p}"
            match = re.search(pattern_1, folders_MMS.name)
            if match:
               ref = match.group(1)
               print(f"Refinement level: {ref}")
               filename = base_dir + '/' + folders_MMS.name + "/L2Error.dat"
               print(filename)
               new_column =  np.genfromtxt(filename, delimiter=None, skip_header=1, dtype=float, invalid_raise=False)
               new_row = new_column[ np.newaxis, :]
               if len(mat) == 0:
                 mat = new_row
               else:
                 mat = np.append(mat, new_row, axis=0)
        
        # Convert the list to a numpy array
        mat = np.array(mat)
        sorted_mat = mat[mat[:, 0].argsort()]  
        # Now add the order of the error in pressure, velocity, and runtime for each two rows and insert it in the column next to it
        cols_to_modify = [2, 4, 6]

        for col in cols_to_modify:
          sorted_mat [1:, col] = np.log(sorted_mat[:-1, col-1]/sorted_mat[1:, col-1])/np.log(2)
        # We now write the file in such a way that it can be read similarly to the L2Error.dat files that are generated by lethe when mesh is automatically refined
        filename = base_dir + '/' + f"mms_2d_steady_degu_{poly_deg_u}_degp_{poly_deg_p}" + "/L2Error.dat"
        def format_value(value, width, col_idx):
             """Format value based on its column index."""
             if np.isnan(value):  # Handle NaN values
                return '- '.rjust(width)
             elif col_idx == 0:  # First column as integer
                return f'{int(value)}'.rjust(width)
             elif col_idx in [1, 3]:  # Columns as .4e
                return f'{value:.4e} '.rjust(width)
             elif col_idx == 5:  # Column 5 as float with 4 decimals
                return f'{value:.4f} '.rjust(width)
             else:  # Default case
                return f'{value:.2f} '.rjust(width)
        # Define column headers
        headers = ["cells", "error_velocity", " ", "error_pressure", " ", "total_time", " "]
       
        with open(filename, 'w') as f:
           header_line = ''.join(f'{header:^{width}}' for header, width in zip(headers, col_widths))
           f.write(header_line + '\n')

           for row in sorted_mat:
              formatted_row = ''.join(format_value(value, width, idx) for idx, (value, width) in enumerate(zip(row, col_widths)))
              f.write(formatted_row + '\n')

# We now create a directory to which we move the generated folders and files within for every single mesh refinement level
initial_output_dir = os.path.join(base_dir, "initial_output")
os.makedirs(initial_output_dir, exist_ok=True)

# Pattern to match directories to be moved
pattern = r"mms_2d_steady_mesh_ref_\d+"

# Find and move matching directories
moved_count = 0
for folder in path.glob("mms*"):
    if folder.is_dir() and re.match(pattern, folder.name):
        # Get the destination path
        dest_path = os.path.join(initial_output_dir, folder.name)
        
        # Move the directory
        print(f"Moving to initial output directory: {folder.name}")
        shutil.move(str(folder), dest_path)
        moved_count += 1

print(f"Moved {moved_count} directories to {initial_output_dir}")


